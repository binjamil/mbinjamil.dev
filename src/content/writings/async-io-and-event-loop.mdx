---
title: "Asynchronous I/O and the event loop"
description: "What is asynchronous I/O exactly and how does it work under the hoods? In this post, we’re going to be answering these questions and then building a bare-bones event loop from scratch in C to demonstrate async I/O."
pubDate: "Jun 17, 2023"
toc:
  [
    {
      parent: "Models of programming",
      children: ["Synchronous model", "Threaded model", "Asynchronous model"],
    },
    { parent: "Epoll and friends" },
    { parent: "The event loop" },
    { parent: "References" },
    { parent: "Further reading" },
  ]
---
import AccessibleImage from '../../components/AccessibleImage.astro';

Asynchronous programming model has become so popular these days that programmers use it without actually understanding it. This leads to confusions such as conflating concurrency with parallelism. What is asynchronous I/O exactly and how does it work under the hoods? In this post, we're going to be answering these questions and then building a bare-bones event loop from scratch in C to demonstrate async I/O.

## Models of programming

Programming model is an abstract concept that explains how the program is structured and how it will run when executed. In order to appreciate asynchronous programming model, we need to first talk about two other ways to structure programs.

### Synchronous model

Synchronous model is the most simple one and, as the name implies, it runs tasks one at a time. Any task that is currently running must complete fully before another one can be scheduled. This means that future tasks need to wait for previous ones to be completed; hence, synchronous. This model is not well-suited for I/O-bound workloads, i.e. a program that initiates a lot of I/O requests.

<AccessibleImage name="asyncio-sync" alt="Synchronous programming model" width="189" />

I/O is an abbreviation of input/output and it refers to any task that does not involve CPU computation. Examples include reading from a disk or writing data to some network. I/O tasks are orders of magnitude slower than CPU tasks. In synchronous, single-threaded programming model, the CPU becomes idle whenever an I/O task is initiated. Nothing else can be done until the completion of I/O. Therefore, to gain maximum performance, we need to model our programs such that the CPU is not sitting idle waiting for I/O most of the time.

### Threaded model

Threaded model runs each task, or a bunch of tasks, on a separate thread of control which are managed by the OS. On a multi-threaded microchips, some number of these threads will run in parallel. This is great since the time needed to run multiple tasks is reduced significantly and the program is utilizing as much performance as available by the underlying hardware.

<AccessibleImage name="asyncio-threaded" alt="Threaded programming model" width="410" />

There are, however, two problems with the threaded model. First, each thread will still sit idle when an I/O request is initiated, and we lose CPU time that could be potentially used elsewhere. Second, multi-threaded models are hard to program and reason about. In single-threaded model, a future task has the guarantee that previous tasks are completed successfully. Since the order of task completion is arbitrary in multi-threaded programs, there is no such guarantee. To overcome this, we have to use concurrency constructs such as locks or shared memory, which are complex and error-prone.

### Asynchronous model

Asynchronous model is the only paradigm that actually addresses the central problem: blocking I/O. In this model, the tasks are interleaved such that minimum amount of time is spent waiting for I/O. So, say when a task A performs an I/O request, it yields control back to the program instead of blocking it. The program can now run other tasks freely. After some amount of time, the program will re-run the paused task A given that its I/O request is completed.

<AccessibleImage name="asyncio-async" alt="Asynchronous programming model" width="189" />

Asynchronous model is great because of its unblocking nature, so that the program utilizes as much CPU time as possible. Also, this model is slightly easier to work with since it is inherently single-threaded. Hence, you don’t have to deal with the complexities of cooperating multiple threads. Generally, [asynchronous I/O model performs similar or better than its threaded counterpart](https://unixism.net/2019/04/linux-applications-performance-introduction/).


## Epoll and friends

## The event loop

## References

https://unixism.net/2019/04/linux-applications-performance-introduction/

## Further reading

